# https://esphome.io/guides/configuration-types.html#substitutions
substitutions:

  # substitutions can be changed here if you are using this file directly in the ESPHome dashboard.  The better approach is
  # to incorporate this file as a package using the following packages: configuration, and then overwrite these substitutions
  # in your local yaml file by redefining them.
  #
  # packages:
  #   kauf.rgbsw: github://bkaufx/kauf-rgb-switch/kauf-rgbs.yaml
  #

  name: kauf-rgbsw             # **** CHANGE DEVICE NAME TO SOMETHING UNIQUE PER DEVICE.  RENAME YAML FILE TO SAME NAME.    ****
                               # **** USE DASHES (-) INSTEAD OF SPACES OR UNDERSCORE (_).  USE ONLY LOWER CASE LETTERS.     ****
  friendly_name: Kauf RGB Sw   # **** CHANGE FRIENDLY NAME TO SOMETHING UNIQUE PER DEVICE                                   ****

  # https://esphome.io/components/esphome.html#esphome-creators-project
  project_name: Kauf.RGBSw
  project_ver_num: "1.30"
  project_ver_let: l

  disable_entities: "true"     # set to "false" to have all entities show up in Home Assistant automatically

  # substitutions for button press and release.  
  # any length of hold can be implemented with just on_press and on_release using the following directions.
  #   * have a delay for the desired hold in the on_press script
  #   * place actions in the on_press script after the delay to perform them while still holding the button
  #   * place actions in the on_release script, with the condition that the on_press script is not running, to
  #     perform them on release of the button.
  #   * stop the on_press script in the on_release script so that on_press actions do not get executed if timer didn't run out.
  
  # You can implement separate hold and press actions by:
  #   on_press:   delay for desired length of hold then perform hold action
  #   on_release: if on_press is still running, do press action and stop on_press script.

  # the built-in on_press and on_release automations for the button will still do everything they normally do even
  # when these substitutions are redefined.  Redefining these will not stop the ui switch from toggling.  The disable
  # button configuration switch must be turned on to stop the button from toggling the ui switch.  The button press
  # duration sensor will also still update even with these redefined.
  sub_on_press:    script_do_nothing   # executes right when button is pressed
  sub_on_release:  script_do_nothing   # executes right when button is released

  # these will execute when ui_switch turns on and off, respectively.  like on_press and on_release above, built-in
  # automations still all run.  Lights changing can be disabled through the config light entity effects.  Relay
  # can be disabled by selecting always on or always off in the configuration select entity.  You can control the
  # relay independently by toggling the select entity between always on and always off.
  sub_on_turn_on:  script_do_nothing
  sub_on_turn_off: script_do_nothing

  # allows status led to be blocked.  Currently only used on factory image to eliminate blinking during factory test.
  sub_blink_check: script_do_nothing

# https://esphome.io/components/esp8266.html
esp8266:
  board: esp01_1m
  restore_from_flash: true
  early_pin_init: false


# https://esphome.io/guides/automations.html#global-variables
globals:
  - id: global_press_time
    type: int
    restore_value: no
    initial_value: '0'


# https://esphome.io/components/esphome.html
esphome:
  name: $name
  project:
    name: $project_name
    version: $project_ver_num($project_ver_let)


# https://esphome.io/components/wifi.html
wifi:

  # **** ENTER WI-FI CREDENTIALS HERE, USING SECRETS.YAML RECOMMENDED ****
  ssid: initial_ap            # !secret wifi_ssid
  password: asdfasdfasdfasdf  # !secret wifi_password

  # default is 20, 17 is recommended.
  output_power: 17

  # using fast_connect as default since it is required for hidden networks.
  fast_connect: true


# https://esphome.io/components/logger.html
logger:


# https://esphome.io/components/api.html
api:
  id: kauf_api


# https://esphome.io/components/ota.html
ota:
  on_error:
    then:
      - button.press: restart_button


# https://esphome.io/components/web_server.html
web_server:
  local: true


# https://esphome.io/components/binary_sensor/index.html
binary_sensor:

    # https://esphome.io/components/binary_sensor/gpio.html
  - platform: gpio
    id: main_button
    name: $friendly_name Button
    pin:
      number: GPIO13
      mode:
        input: true
        pullup: true
      inverted: true
    on_press:
        then:
            # store press time in ms
          - lambda: |-
              // store time of press and clear duration sensor
              id(global_press_time) = millis();
              id(sensor_press_duration).publish_state(0);

              // toggle if button not disabled
              if (!id(disable_button).state) {
                id(ui_switch).toggle(); }
          - script.execute: $sub_on_press

    on_release:
        then:
            # set duration sensor
          - lambda: id(sensor_press_duration).publish_state(millis() - id(global_press_time));
          - script.execute: $sub_on_release


# https://esphome.io/components/switch/index.html
switch:
  - platform: gpio
    id: relay
    pin: GPIO15

    # https://esphome.io/components/switch/template.html
  - platform: template
    name: $friendly_name
    id: ui_switch
    restore_state: true
    optimistic: true
    on_turn_on:
      then:
        - lambda: |-
            // waiting for select entity to have a state keeps the relay from toggling during boot
            if ( id(select_relay).has_state() && ( id(select_relay).state != "Always Off" ) ) {
              id(relay).turn_on(); }
        - script.execute: copy_vals
        - script.execute: script_save_changes
        - script.execute: $sub_on_turn_on

    on_turn_off:
      then:
        - lambda: |-
            // waiting for select entity to have a state keeps the relay from toggling during boot
            if ( id(select_relay).has_state() && ( id(select_relay).state != "Always On" ) ) {
              id(relay).turn_off(); }
        - script.execute: copy_vals
        - script.execute: script_save_changes
        - script.execute: $sub_on_turn_off

  - platform: template
    id: switch_no_hass
    name: $friendly_name No HASS
    optimistic: true
    restore_state: true
    entity_category: config
    disabled_by_default: $disable_entities
    icon: mdi:toggle-switch-off-outline
    on_turn_on:
      - lambda: |-
          id(kauf_api)->set_reboot_timeout(0);  // 0 disables auto rebooting and also new status led blinking.  doesn't stop current status led blinking
          id(kauf_api)->status_clear_warning(); // stops current status led blinking, timeout 0 keeps it from restarting
      - script.execute: script_save_changes      
    on_turn_off:
      - lambda: id(kauf_api)->set_reboot_timeout(900000);
      - script.execute: script_save_changes

  - platform: template
    id: disable_button
    name: $friendly_name Disable Button
    optimistic: true
    restore_state: true
    entity_category: config
    icon: mdi:toggle-switch-off-outline
    on_turn_on:
      - script.execute: script_save_changes
    on_turn_off:
      - script.execute: script_save_changes


# PWM outputs for each LED channel
# https://esphome.io/components/output/esp8266_pwm.html
output:

    # small light pwm
  - platform: esp8266_pwm
    pin: GPIO0
    frequency: 250 Hz
    id: pwm1_red
    inverted: true
  - platform: esp8266_pwm
    pin: GPIO12
    frequency: 250 Hz
    id: pwm1_green
    inverted: true
  - platform: esp8266_pwm
    pin: GPIO2
    frequency: 250 Hz
    id: pwm1_blue
    inverted: true

    # big light pwm
  - platform: esp8266_pwm
    pin: GPIO14
    frequency: 250 Hz
    id: pwm2_red
  - platform: esp8266_pwm
    pin: GPIO5
    frequency: 250 Hz
    id: pwm2_green
    max_power: .4
  - platform: esp8266_pwm
    pin: GPIO4
    frequency: 250 Hz
    id: pwm2_blue
    max_power: .35

    # bit bucket output to connect fake lights to
    # one channel per fake light is connected to bucket1 to trigger script
    # other channels are connected to bucket2 to do nothing.  Only need script
    # to run once per light change.
    # https://esphome.io/components/output/template.html  
  - platform: template
    id: bit_bucket1
    type: float
    write_action:
      - script.execute: copy_vals
  - platform: template
    id: bit_bucket2
    type: float
    write_action:
      - script.execute: script_do_nothing


# https://esphome.io/components/light/index.html
# https://esphome.io/components/light/rgb.html
light:

  - platform: rgb
    name: $friendly_name Small Light
    id: kauf_light1
    red: pwm1_red
    green: pwm1_green
    blue: pwm1_blue
    default_transition_length: 333ms

  - platform: rgb
    name: $friendly_name Small Off Value
    id: kauf_light1_off
    red: bit_bucket1
    green: bit_bucket2
    blue: bit_bucket2
    entity_category: config
    default_transition_length: 0s
    effects:
      - lambda:
          name: Disabled
          update_interval: never
          lambda: return;
    
  - platform: rgb
    name: $friendly_name Small On Value
    id: kauf_light1_on
    red: bit_bucket1
    green: bit_bucket2
    blue: bit_bucket2
    entity_category: config
    default_transition_length: 0s
    effects:
      - lambda:
          name: Disabled
          update_interval: never
          lambda: return;
    
  - platform: rgb
    name: $friendly_name Big Light
    id: kauf_light2
    red: pwm2_red
    green: pwm2_green
    blue: pwm2_blue
    default_transition_length: 333ms

  - platform: rgb
    name: $friendly_name Big Off Value
    id: kauf_light2_off
    red: bit_bucket1
    green: bit_bucket2
    blue: bit_bucket2
    entity_category: config
    default_transition_length: 0s
    effects:
      - lambda:
          name: Disabled
          update_interval: never
          lambda: return;

  - platform: rgb
    name: $friendly_name Big On Value
    id: kauf_light2_on
    red: bit_bucket1
    green: bit_bucket2
    blue: bit_bucket2
    entity_category: config
    default_transition_length: 0s
    effects:
      - lambda:
          name: Disabled
          update_interval: never
          lambda: return;


# https://esphome.io/components/select/index.html
# https://esphome.io/components/select/template.html
select:
  - platform: template
    name: $friendly_name Relay Config
    id: select_relay
    optimistic: true
    options:
      - Switched
      - Always On
      - Always Off
    initial_option: Switched
    restore_value: true
    entity_category: config
    icon: mdi:progress-question
    on_value:
      then:
        - lambda: |-
            if      ( x == "Always On"  )   { id(relay).turn_on();  }
            else if ( x == "Always Off" )   { id(relay).turn_off(); }
            else if ( id(ui_switch).state ) { id(relay).turn_on();  }
            else      /* ui_switch off */   { id(relay).turn_off(); }
        - script.execute: script_save_changes      


# https://esphome.io/guides/automations.html#script-component
script:

  - id: blink_status_led
    mode: queued
    then:

      # allows the blinking to be blocked if desired by overwriting script substitution
      - script.execute: $sub_blink_check

      # set LED red for ? ms then off for ? ms, then repeat
      - lambda: |-
          auto call = id(kauf_light1).turn_on();
          call.set_brightness(1.0f);
          call.set_transition_length(0);
          call.set_rgb(1.0f, 0.0f, 0.0f);
          call.perform();
      - delay: 350ms
      - lambda: |-
          auto call = id(kauf_light1).turn_off();
          call.set_transition_length(0);
          call.perform();
      - delay: 1150ms
      - if:
          condition:
            - lambda: return ( ( (App.get_app_state() & STATUS_LED_ERROR) != 0u) || ((App.get_app_state() & STATUS_LED_WARNING) != 0u) );
          then:
            - script.execute: blink_status_led # repeat as long as api not connected
          else:
            - script.execute: copy_vals        # restore set colors if api is connected

  - id: script_do_nothing
    then:
      - lambda: return;

  - id: script_save_changes
    mode: restart
    then:
      - delay: 3s
      - lambda: global_preferences->sync();

  # script to copy values from config lights to real lights per switch state
  - id: copy_vals
    mode: restart
    then:
      - lambda: |-

          // switch is on, copy on values
          if ( id(ui_switch).state && (kauf_light1_on->get_effect_name() != "Disabled") ) {
            if ( kauf_light1_on->current_values.is_on() ) {
              auto call = id(kauf_light1).turn_on();
              call.set_brightness(kauf_light1_on->current_values.get_brightness());
              call.set_rgb(kauf_light1_on->current_values.get_red(),
                           kauf_light1_on->current_values.get_green(),
                           kauf_light1_on->current_values.get_blue());
              call.perform();
            }
            else {
              auto call = id(kauf_light1).turn_off();
              call.perform();
            }
          }

          if ( id(ui_switch).state && (kauf_light2_on->get_effect_name() != "Disabled") ) {
            if ( kauf_light2_on->current_values.is_on() ) {
              auto call = id(kauf_light2).turn_on();
              call.set_brightness(kauf_light2_on->current_values.get_brightness());
              call.set_rgb(kauf_light2_on->current_values.get_red(),
                           kauf_light2_on->current_values.get_green(),
                           kauf_light2_on->current_values.get_blue());
              call.perform();
            }
            else {
              auto call = id(kauf_light2).turn_off();
              call.perform();
            }
          }

          // switch is off, copy off values
          if ( !id(ui_switch).state && (kauf_light1_off->get_effect_name() != "Disabled") ) {
            if ( kauf_light1_off->current_values.is_on() ) {
              auto call = id(kauf_light1).turn_on();
              call.set_brightness(kauf_light1_off->current_values.get_brightness());
              call.set_rgb(kauf_light1_off->current_values.get_red(),
                           kauf_light1_off->current_values.get_green(),
                           kauf_light1_off->current_values.get_blue());
              call.perform();
            }
            else {
              auto call = id(kauf_light1).turn_off();
              call.perform();
            }
          }

          if ( !id(ui_switch).state && (kauf_light2_off->get_effect_name() != "Disabled") ) {
            if ( kauf_light2_off->current_values.is_on() ) {
              auto call = id(kauf_light2).turn_on();
              call.set_brightness(kauf_light2_off->current_values.get_brightness());
              call.set_rgb(kauf_light2_off->current_values.get_red(),
                           kauf_light2_off->current_values.get_green(),
                           kauf_light2_off->current_values.get_blue());
              call.perform();
            }
            else {
              auto call = id(kauf_light2).turn_off();
              call.perform();
            }
          }


# https://esphome.io/components/button/index.html
# https://esphome.io/components/button/restart.html
button:
  - platform: restart
    id: restart_button
    name: $friendly_name Restart Firmware
    entity_category: diagnostic
    disabled_by_default: $disable_entities


# Send IP Address to HA
# https://esphome.io/components/text_sensor/wifi_info.html
text_sensor:
  - platform: wifi_info
    ip_address:
      name: $friendly_name IP Address
      entity_category: diagnostic
      disabled_by_default: $disable_entities


# https://esphome.io/components/sensor/index.html
sensor:

    # https://esphome.io/components/sensor/template.html
  - platform: template
    name: $friendly_name Button Press Duration
    id: sensor_press_duration
    entity_category: diagnostic
    disabled_by_default: $disable_entities
    unit_of_measurement: ms
    icon: mdi:timer-outline

    # https://esphome.io/components/sensor/uptime.html
  - platform: uptime
    name: $friendly_name Uptime
    update_interval: 60s
    entity_category: diagnostic
    disabled_by_default: $disable_entities


# emulate status_led
# https://esphome.io/guides/automations.html#interval-component
interval:
  - interval: 5s
    then:
      if:
        condition:
          - lambda: return ( ( (App.get_app_state() & STATUS_LED_ERROR) != 0u) || ((App.get_app_state() & STATUS_LED_WARNING) != 0u) );
        then:
          - if:
              condition:
                not:
                  - script.is_running: blink_status_led
              then:
                - script.execute: blink_status_led


# Current reserved flash memory:
#  00- 01:   Relay Switch
#  02- 03:   UI Switch
#  04- 05:   No HASS Switch
#  06- 07:   Disable Button Switch
#  10- 21:   Small Light
#  22- 33:   Small Off Value Light
#  34- 45:   Small On Value Light
#  46- 57:   Big Light
#  58- 69:   Big Off Value Light
#  70- 81:   Big On Value Light
#  82-107:   Wi-Fi Credentials
